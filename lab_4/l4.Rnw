\documentclass{article}

\title{Algorytmy i metody detekcji społeczności}

\author{
  Karol Działowski \\
  Zachodniopomorski Uniwersytet Technologiczny
}


\usepackage{C:/Dev/complex_networks/lab_4/arvix}

\usepackage[utf8]{inputenc} % allow utf-8 input
\usepackage[T1]{fontenc}    % use 8-bit T1 fonts
\usepackage{hyperref}       % hyperlinks
\usepackage{url}            % simple URL typesetting
\usepackage{booktabs}       % professional-quality tables
\usepackage{amsfonts}       % blackboard math symbols
\usepackage{nicefrac}       % compact symbols for 1/2, etc.
\usepackage{microtype}      % microtypography
\usepackage{lipsum}
\usepackage[polish]{babel} % English language hyphenation
\usepackage{float} % for H in \begin{figure}[H]. Force including file in place.
\usepackage{listings}
\usepackage{subcaption}
\usepackage{siunitx}
\usepackage{multirow}

\usepackage{graphicx}
\graphicspath{ {./images/} }


% kolory odnośników
\usepackage[dvipsnames]{xcolor}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    pdftitle={Sharelatex Example},
    bookmarks=true,
    pdfpagemode=FullScreen,
    }
\urlstyle{same}

% Listings
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{
    language=r,
    basicstyle=\small\sffamily,
    numbers=left,
    numberstyle=\tiny,
    frame=tb,
    columns=fullflexible,
    showstringspaces=false,
    style=mystyle
}
\begin{document}
\SweaveOpts{concordance=TRUE}
\maketitle

\section{Zadanie wprowadzające}

\subsection{Detekcja społeczności}

<<>>=
library("igraph")
graph <- sample_gnm(n=30, m=30)
plot(graph, vertex.label=NA, vertex.size=18, vertex.label.cex = 1.3)

communities <- cluster_louvain(graph, weights = NULL)
length(communities) # liczba spolecznosci
sizes(communities) # rozmiary spolecznosci
members <- membership(communities) # w tablicy dla kazdego wezla przypisane jest community id
modularity(communities)
crossing(communities, graph) # lacznosc pomiedzy spolecznosciami 
@


\subsection{Wizualizacja społeczności}

\subsubsection{Wizualizacja społeczności na grafie}


<<>>=
plot(communities, graph)
@

\begin{figure}[H]
\centering
<<fig=TRUE, echo=FALSE, fig.align='center'>>=
plot(communities, graph)
@
\caption{Wizualizacja społeczności}
\label{fig:test}
\end{figure}


\subsubsection{Dendrogram i pdejście hierarchiczne}

<<>>=
karate <- make_graph("Zachary")
fc <- cluster_fast_greedy(karate)
plot_dendrogram(fc)
plot(fc, karate)
@

\begin{figure}[H]
\centering
\begin{subfigure}{.49\linewidth}
  \centering
<<fig=TRUE, echo=FALSE, fig.align='center'>>=
plot_dendrogram(fc)
@
  \caption{Dendrogram}
\end{subfigure}
\begin{subfigure}{.49\linewidth}
  \centering
<<fig=TRUE, echo=FALSE, fig.align='center'>>=
plot(fc, karate)
@
  \caption{Podejscie hierarhiczne}
\end{subfigure}
\caption{Dendrogram i podejscie hierarhiczne}
\end{figure}

\subsection{Inne algorytmy}

<<>>=
# Random walk
cw <- cluster_walktrap(karate, weights = E(graph)$weight, steps = 2, 
                       merges = TRUE, modularity = TRUE, membership = TRUE)
plot_dendrogram(cw)
plot(cw, karate)

# Eigenvector
cl <- cluster_leading_eigen(karate, steps = -1, weights = NULL, 
                            start = NULL, options = arpack_defaults, callback = NULL,
                      extra = NULL, env = parent.frame())
plot_dendrogram(cl)
plot(cl, karate)

# Betweenness krawedzi
ceb <- cluster_edge_betweenness(karate, weights = E(graph)$weight, 
                          directed = TRUE, edge.betweenness = TRUE,
                          merges = TRUE, bridges = TRUE, modularity = TRUE, membership = TRUE)
plot_dendrogram(ceb)
plot(ceb, karate)

# Etykiety & voting
clp <- cluster_label_prop(karate, weights = NULL, initial = NULL, fixed = NULL)
plot(clp, karate)

# Greedy
cfg <- cluster_fast_greedy(karate)
plot(cfg, karate)
@

\begin{figure}[H]
\centering
\begin{subfigure}{.49\linewidth}
  \centering
<<fig=TRUE, echo=FALSE, fig.align='center'>>=
plot_dendrogram(cw)
@
  \caption{Dendrogram cluster walktrap}
\end{subfigure}
\begin{subfigure}{.49\linewidth}
  \centering
<<fig=TRUE, echo=FALSE, fig.align='center'>>=
plot(cw, karate)
@
  \caption{Cluster walktrap}
\end{subfigure}
\\
\begin{subfigure}{.49\linewidth}
  \centering
<<fig=TRUE, echo=FALSE, fig.align='center'>>=
plot_dendrogram(cl)
@
  \caption{Dendrogram cluster leading eigen}
\end{subfigure}
\begin{subfigure}{.49\linewidth}
  \centering
<<fig=TRUE, echo=FALSE, fig.align='center'>>=
plot(cl, karate)
@
  \caption{Cluster leading eigen}
\end{subfigure}
\\
\begin{subfigure}{.49\linewidth}
  \centering
<<fig=TRUE, echo=FALSE, fig.align='center'>>=
plot_dendrogram(ceb)
@
  \caption{Dendrogram cluster edge betweenness}
\end{subfigure}
\begin{subfigure}{.49\linewidth}
  \centering
<<fig=TRUE, echo=FALSE, fig.align='center'>>=
plot(ceb, karate)
@
  \caption{Cluster edge betweenness}
\end{subfigure}
\\
\caption{Inne algorytmy}
\end{figure}

\begin{figure}[H]
\centering
\begin{subfigure}{.49\linewidth}
  \centering
<<fig=TRUE, echo=FALSE, fig.align='center'>>=
plot(clp, karate)
@
  \caption{Cluster label prop}
\end{subfigure}
\begin{subfigure}{.49\linewidth}
  \centering
<<fig=TRUE, echo=FALSE, fig.align='center'>>=
plot(cfg, karate)
@
  \caption{Cluster fast greedys}
\end{subfigure}
\\
\caption{Inne algorytmy}
\end{figure}


\section{Badanie wpływu parametrów sieci syntetycznej na strukturę społeczności w grafie}

\begin{enumerate}
\item Dla wybranego modelu teoretycznego sieci wygenerować 5 sieci z różnymi parametrami i liczbą węzłów około 30
\item Dla każdej sieci z udziałem dowolnego algorytmu wyznaczyć wektor społeczności, modularność, liczbę społeczności i liczbę węzłów w każdej z nich dla grafu nieskierowanego
\item Zwizualizować społeczność w każdej sieci
\item Określić w jaki sposób parametry sieci teoretycznej wpływały na strukturę społeczności
\item Wygenerować mały graf w wersji skierowanej i porównać wyniki działania detekcji społeczności z uwzględnieniem lub bez uwzględnienia wag.
\end{enumerate}

Wygenerowano 5 sieci na podstawie modelu Barabasi-Albert.\cite{Albert_2002} Sterowano parametrami $p$ -- \emph{power}, oraz $m$ -- liczba krawędzi dołączanych w każdym kroku budowy sieci.

<<>>=
ba1 <- sample_pa(n=50, power=1, m=1, directed=F)
ba2 <- sample_pa(n=50, power=2, m=1, directed=F)
ba3 <- sample_pa(n=50, power=3, m=1, directed=F)
ba4 <- sample_pa(n=50, power=1, m=2, directed=F)
ba5 <- sample_pa(n=50, power=1, m=3, directed=F)

communities1 <- cluster_louvain(ba1, weights = NULL)
length(communities1) 
sizes(communities1)
members <- membership(communities1)
modularity(communities1)
crossing(communities1, graph)
plot(communities1, ba1)

communities2 <- cluster_louvain(ba2, weights = NULL)
length(communities2) 
sizes(communities2)
members <- membership(communities2)
modularity(communities2)
crossing(communities2, graph)
plot(communities2, ba2)

communities3 <- cluster_louvain(ba3, weights = NULL)
length(communities3) 
sizes(communities3)
members <- membership(communities3)
modularity(communities3)
crossing(communities3, graph)
plot(communities3, ba3)

communities4 <- cluster_louvain(ba4, weights = NULL)
length(communities4) 
sizes(communities4)
members <- membership(communities4)
modularity(communities4)
crossing(communities4, graph)
plot(communities4, ba4)

communities5 <- cluster_louvain(ba5, weights = NULL)
length(communities5) 
sizes(communities5)
members <- membership(communities5)
modularity(communities5)
crossing(communities5, graph)
plot(communities5, ba4)
@

\begin{figure}[H]
\centering
\begin{subfigure}{.49\linewidth}
  \centering
<<fig=TRUE, echo=FALSE, fig.align='center'>>=
plot(communities1, ba1)
@
  \caption{Model BA $n=50, p=1, m=1$}
\end{subfigure}
\begin{subfigure}{.49\linewidth}
  \centering
<<fig=TRUE, echo=FALSE, fig.align='center'>>=
plot(communities2, ba2)
@
  \caption{Model BA $n=50, p=2, m=1$}
\end{subfigure}
\\
\begin{subfigure}{.49\linewidth}
  \centering
<<fig=TRUE, echo=FALSE, fig.align='center'>>=
plot(communities3, ba3)
@
  \caption{Model BA $n=50, p=3, m=1$}
\end{subfigure}
\begin{subfigure}{.49\linewidth}
  \centering
<<fig=TRUE, echo=FALSE, fig.align='center'>>=
plot(communities4, ba4)
@
  \caption{Model BA $n=50, p=1, m=2$}
\end{subfigure}
\\
\begin{subfigure}{.49\linewidth}
  \centering
<<fig=TRUE, echo=FALSE, fig.align='center'>>=
plot(communities5, ba5)
@
  \caption{Model BA $n=50, p=1, m=3$}
\end{subfigure}
\caption{Porównanie dzialania klasteryzacji na modelu BA}
\end{figure}

Zwiększając parametr $p$ zwiększa się centralność sieci, to znaczy wyłaniają się węzły centralne, do których prawdopodobieństwo przyłączenia się zwiększa. Dla $p=1$ wyróżniono 8 społeczności, gdzie dla $p=3$ były to 3 społeczności.

Parametr $m$ ma wpływ na liczbę połączeń pomiędzy węzłami. To znaczy dla parametru $m=1$ w każdej iteracji tworzona jest jedna krawędź dla węzła. Zwiększając ten parametr zwiększa się liczba krawędzi w grafie, a co za tym idzie trudniej jeest wyłonić jednoznacznie społeczności. Dla $m=2$ i $m=3$ wyznaczono odpowiednio 7 i 8 społeczności.

Następnie wygenerowano mały graf w wersji skierowanej i porównano wyniki działania detekcji społeczności z uwzględnieniem lub bez uwzględnienia wag.

<<>>=
g <- sample_pa(n=50, power=1, m=1, directed=T)

communities <- cluster_edge_betweenness(g, weights = NULL, directed = FALSE)
length(communities) 
sizes(communities)
members <- membership(communities)
plot(communities, g)

E(g)$weight <- seq_len(ecount(g))

communities <- cluster_edge_betweenness(g, weights = E(g)$weight, directed = TRUE)
length(communities) 
sizes(communities)
members <- membership(communities)
plot(communities, g)
@

Liczności dla wygenerowanego grafu skierowanego z uwzględnieniem wag nieznacznie się różnią od grafu z pominiętymi kierunkami wierzchołków i wagami węzłów. Liczba społeczności jest identyczna.


\section{Badanie struktury społeczności sieci rzeczywistej}

\begin{enumerate}
\item Dla wybranej sieci rzeczywistej (np. wykorzystywanej w zadaniu z Lab 3) wyznaczyć społeczności, modularność, liczbę społeczności i liczbę węzłów w każdej z nich.
\item Zwizualizować społeczności na grafie.
\item Zliczyć dla każdej społeczności liczbę powiązań zewnętrznych.
\item Wyznaczyć dla każdej społeczności średni stopień wierzchołka. Można wykorzystać w tym celu obiekt data frame i połączyć w nim wektor degree z wektorem uzyskanym z communities który przypisuje do każdego węzła identyfikator społeczności. Załączyć w sprawozdaniu kod wymagany do realizacji obliczeń.
\end{enumerate}


<<>>=
net <- read.graph("../data/voles/mammalia-voles-rob-trapping-11.edges", format = "edgelist")
plot(net)

communities <- cluster_edge_betweenness(net, weights = NULL)
length(communities) 
sizes(communities)
members <- membership(communities)
modularity(communities)
crossing(communities, graph)
plot(communities, net)
@

\begin{figure}[H]
\centering
<<fig=TRUE, echo=FALSE, fig.align='center'>>=
plot(communities, net)
@
\caption{Wizualizacja społeczności w sieci karczowników}
\label{fig:test}
\end{figure}


\end{document}

% TODO:
% - [ ] wykreślenie plotów dla badania skierowanych z wagami 
% - [x] wczytanie sieci rzeczywistej
% - [x] wyznaczanie mair w sieci rzeczywistej
% - [x] wizualizacja społeczności w sieci rzeczywistej
% - [ ] dla każdej społeczności wyznaczyć średni stopień wierzchołka
% - [ ] opisać badanie sieci rzeczywistej